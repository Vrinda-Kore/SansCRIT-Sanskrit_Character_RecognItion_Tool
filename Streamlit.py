'''
import streamlit as st
from PIL import Image
import tensorflow as tf
import numpy as np

# Load the trained model
model = tf.keras.models.load_model('cnn_1.h5')

# Create a function to make predictions
def make_prediction(image):
    # Preprocess the image
    img = np.array(image)
    # Perform any necessary preprocessing steps (resize, normalize, etc.)

    # Make prediction
    prediction = model.predict(img)
    return prediction

# Streamlit application interface
st.title('Your Image Classification App')
uploaded_file = st.file_uploader("Choose an image...", type=["jpg", "png"])

if uploaded_file is not None:
    # Display the uploaded image
    image = Image.open(uploaded_file)
    st.image(image, caption='Uploaded Image', use_column_width=True)

    # Make a prediction on the uploaded image
    prediction = make_prediction(image)

    # Display the prediction or results
    st.write('Prediction:', prediction)
'''
import streamlit as st
from PIL import Image
import numpy as np
import tensorflow as tf
import cv2
import unicodedata
from keras.utils import load_img, img_to_array

lower = tf.keras.models.load_model('vrinda.h5')
upper = tf.keras.models.load_model('vijitha.h5')  
half = tf.keras.models.load_model('dhruva.h5')  
full = tf.keras.models.load_model('sahana.h5') 






full_indices = ['0X0927', '0x0903', '0x0905', '0x0907', '0x0909', '0x090A', '0x090B', '0x090C', '0x090F', '0x0915', '0x0915,0x094D,0x0924', '0x0915,0x094D,0x092F', '0x0915,0x094D,0x0937', '0x0915,0x94D,0x0935', '0x0916', '0x0917', '0x0918', '0x0919', '0x0919,0x094D,0x917', '0x091A', '0x091B', '0x091C', '0x091C,0x094D,0x091C', '0x091C,0x094D,0x091E', '0x091C,0x094D,0x0935', '0x091D', '0x091E', '0x091E,0x094D,0x091C', '0x091E,0x094D,0x092F', '0x091F', '0x0920', '0x0921', '0x0922', '0x0923', '0x0924', '0x0924,0x094D,0x0915', '0x0924,0x094D,0x0924', '0x0924,0x094D,0x0925', '0x0924,0x094D,0x0928', '0x0924,0x094D,0x092F', '0x0924,0x094D,0x0930', '0x0925', '0x0926', '0x0926,0x094D,0x0927', '0x0926,0x094D,0x092D', '0x0927,0x094D,0x092F', '0x0928', '0x0928,0X094D,0x0927', '0x0928,0x094D,0x0924', '0x0928,0x094D,0x0928', '0x0928,0x094D,0x092E', '0x0928,0x094D,0x092F', '0x092A', '0x092A,0x094D,0x0924', '0x092A,0x094D,0x0930', '0x092B', '0x092C', '0x092C,0x094D,0x0926', '0x092D', '0x092E', '0x092E,0x094D,0x0924', '0x092E,0x094D,0x0928', '0x092E,0x094D,0x092E', '0x092E,0x094D,0x0938', '0x092F', '0x0930', '0x0932', '0x0932,0x094D,0x092A', '0x0932,0x094D,0x0932', '0x0935', '0x0936,0x094D', '0x0936,0x094D,0x0930', '0x0937', '0x0937,0x094D,0x091F', '0x0937,0x094D,0x0920', '0x0937,0x094D,0x0924', '0x0937,0x094D,0x0925', '0x0937,0x094D,0x092A', '0x0937,0x094D,0x092F', '0x0938', '0x0938,0x094D,0x0915', '0x0938,0x094D,0x0924', '0x0938,0x094D,0x0924,0x094D,0x0930', '0x0938,0x094D,0x0925', '0x0938,0x094D,0x0928', '0x0938,0x094D,0x092A', '0x0938,0x094D,0x092E', '0x0938,0x094D,0x092F', '0x0938,0x094D,0x0935', '0x0939', '0x0939,0x094D,0x0928', '0x093D', '0x093E', '0x0960', '0x0964', '0x0965']
half_indices = ['0x090C,0x094D', '0x0915,0x094D', '0x0915,0x094D,0x0937,0x094D', '0x0916,0x094D', '0x0917,0x094D', '0x0918,0x094D', '0x091A,0x094D', '0x091B,0x094D', '0x091C,0x094D', '0x091C,0x094D,0x091E,0x094D', '0x091D,0x094D', '0x091E,0x094D', '0x0923,0x094D', '0x0924,0x094D', '0x0924,0x094D,0x0930,0x094D', '0x0925,0x094D', '0x0927,0x094D', '0x0928,0x094D', '0x092A,0x094D', '0x092B,0x094D', '0x092C,0x094D', '0x092D,0x094D', '0x092E,0x094D', '0x092F,0x094D', '0x0932,0x094D', '0x0935,0x094D', '0x0936,0x094D', '0x0936,0x094D,0x0930,0x094D', '0x0937,0x094D', '0x0938,0x094D']
low_indices = ['0x093C', '0x0941', '0x0942',  '0x0943',  '0x0944', '0x094D']



upper_indices = ['0x0901', '0x0902', '0x0930,0x094D', '0x0930,0x094D,0x0902', '0x093C', '0x093F', '0x0945', '0x0947', '0x0947,0x0930,0x094D', '0x0948']


def predict_character(test_image, loaded_model, class_indices):
    test_image=img_to_array(test_image)
    test_image=np.expand_dims(test_image,axis=0)
    result=loaded_model.predict(test_image)
    #training_set.class_indices
    predicted_class_index=np.argmax(result)


    #class_indices = {'0': '0x093C', '1': '0x0941', '2': '0x0942', '3': '0x0943', '4': '0x0944', '5': '0x094D'}
    character = class_indices[int(predicted_class_index)]
    # script_character = unicodedata.name(chr(int(character, 16)))
    # score = 100 * np.max(tf.nn.softmax(result))
    return character

def predict_full_char():
    test_image=load_img(uploaded_file,target_size=(64,64))
    test_image=img_to_array(test_image)
    test_image=np.expand_dims(test_image,axis=0)
    result=full.predict(test_image)
    predicted_class_index=np.argmax(result)
    character=full_indices[int(predicted_class_index)]
    # score = 100 * np.max(tf.nn.softmax(result))
    return character

st.title('Sanskrit Character Predictor')
option = st.selectbox('Modifier type: ', ('upper','middle','lower'))
st.write('You selected:', option)
print(option)
uploaded_file = st.file_uploader("Upload your image", type=["jpg", "jpeg","png"])

if uploaded_file is not None:
    image = Image.open(uploaded_file)
    st.image(image, caption='Uploaded Image.', use_column_width=False, width = 100)

    if(option=='lower'):
        image = image.resize((28, 28))
        character= predict_character(image,lower,low_indices)
    elif (option=='upper'):
        image = image.resize((28, 28))
        character = predict_character(image,upper,upper_indices)
    else:
        character= predict_full_char()
    label=character.split(",")
    devanagari_characters = ''.join([chr(int(code_point,16)) for code_point in label])
    print(devanagari_characters)
    st.write(f"Predicted character: \t{devanagari_characters}")


